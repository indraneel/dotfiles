#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <unistd.h>
#include "cacheblock.h"

#define KB 1024
#define MB 1024 *1024
#define ARRAY_SIZE 4*1024*4096

/*
 * cache (int stride, int large)
 * takes an integer input for stride length that will be the amount the index to the array increments by
 * takes an integer input for a large number that will be the amount of times the access loop is run
 * returns the time taken to access values in the array. this time will spike up when access size is 64 bytes, which is the 
 * cache block size. at 64, the cache has to look in the next block, causing the increase in time.
 */
float cache(stride,large){
    register* a;
    a = (int *)malloc(ARRAY_SIZE * sizeof(int));
    int times, i, dummy;
    float timeTaken;

    gettimeofday(&start, NULL);
    for (times=0; times<large; times++){
	for (i=0; i<ARRAY_SIZE; i+=stride){
	    dummy = a[i];
	}
	/* printf("iteration# = %d\n", times);*/
    }
    gettimeofday(&end, NULL);

    timeTaken = (end.tv_sec * 1000000 + end.tv_usec) - (start.tv_sec * 1000000 + start.tv_usec);

    timeTaken = timeTaken/(ARRAY_SIZE/stride);
   
    free(a);
    return timeTaken;
}

int main(int argc, char *argv[]){
   register* a;
   register l;
   float T, T1, T2;
   a = sbrk(ARRAY_SIZE+8192);
   a = (int *)((((int)a>>13)<<13)+8192);

   int strides[] = {32,34,36,38,44,50,51,52,53,54,55,56,57,58,64};

   for (l=0; l<15; l++){
       T1 = cache(strides[l], 500);
       T2 = cache(strides[l], 1000);
       T = (T1-T2)/(500-1000);
       printf("Access Size: %d\t\tTime Taken = %0.12f\n", strides[l], T);
   }

   return 0;
}
