/*
 *********************************************
 *  314 Principles of Programming Languages  *
 *  Spring 2013                              *
 *  Authors: Ulrich Kremer                   *
 *           Hans Christian Woithe           *
 *********************************************
 */

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "InstrUtils.h"
#include "Utils.h"

#define EMPTY_FIELD 0xFFFFF

static inline int calculate(OpCode op, int x, int y){
    switch(op) {
	/*add*/
	case 3:
	    return x+y;
	/*sub*/
	case 4:
	    return y-x;
	/*mul*/
	case 5:
	    return x*y;
	/*error*/
	default:
	    return NULL;
    }
}

int main()
{
	Instruction *head, *newNode;
	Instruction *instr1, *instr2, *instr3;
	int opt_flag, opt_calc;
	int changed;
	head = ReadInstructionList(stdin);
	if (!head) {
		ERROR("No instructions\n");
		exit(EXIT_FAILURE);
	}

	/* YOUR CODE GOES HERE */
	instr3 = head;

	do {
		changed = 0;    
	while (instr3 != NULL) {

	if (instr3->next == NULL){
		break;
	}

	instr2 = instr3->next;
	if (instr3->next->next == NULL){
		break;
	}		
	instr1 = instr2->next;

	if (instr1 == NULL || instr2 == NULL || instr3 == NULL ){
	    ERROR("Instr. list is too short\n");
	    exit(EXIT_FAILURE);
	}

	if ((instr3->opcode == 1) && (instr2->opcode == 1) && ( (instr1->opcode == 3) || (instr1->opcode == 4) || (instr1->opcode == 5) )){
		
		instr3->opcode = 1;
		instr3->field1 = instr1->field1;
		instr3->field2 = calculate(instr1->opcode, instr2->field2, instr3->field2);

		if (instr1->next == NULL){
			instr3->next = NULL;
		}
		else {
			instr3->next = instr1->next;	
		}
		
		instr2 = NULL;
		instr1 = NULL;
		
		free(instr1);
		free(instr2);				
		
		changed = 1;
	}
	
	else {
		
	    if (instr3->next == NULL){
		instr3 = NULL;
	    }
	    else {
		instr3 = instr3->next;
	    }

	}

	}
	changed = 0;
} while (changed == 1);
	PrintInstructionList(stdout, head);
	DestroyInstructionList(head);
	return EXIT_SUCCESS;
}
