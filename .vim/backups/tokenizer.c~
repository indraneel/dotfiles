/*
 * tokenizer.c
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef enum {false, true} bool;

/*
 * Tokenizer type.  You need to fill in the type as part of your implementation.
 */

struct TokenizerT_ {
    char *sep;
    char *tokens_string;
    bool *ascii_hash;
    int length;
    int pos;
};

typedef struct TokenizerT_ TokenizerT;

/*
 * TKCreate creates a new TokenizerT object for a given set of separator
 * characters (given as a string) and a token stream (given as a string).
 * 
 * TKCreate should copy the two arguments so that it is not dependent on
 * them staying immutable after returning.  (In the future, this may change
 * to increase efficiency.)
 *
 * If the function succeeds, it returns a non-NULL TokenizerT.
 * Else it returns NULL.
 *
 * You need to fill in this function as part of your implementation.
 */

TokenizerT *TKCreate(char *separators, char *ts) {
    int i;
    /* allocate space for TokenizerT struct */
    TokenizerT *tokenizer = (TokenizerT *) malloc(sizeof(TokenizerT));
    if (tokenizer == NULL) {
	return NULL;
    }
    
    tokenizer->sep = (char *)malloc(sizeof(strlen(separators)+1));
    if (tokenizer->sep == NULL) {
	return NULL;
    }
    strcpy(tokenizer->sep, separators);

    tokenizer->tokens_string = (char *)malloc(sizeof(strlen(ts)+1));
    if (tokenizer->tokens_string == NULL) {
	return NULL;
    }
    strcpy(tokenizer->tokens_string, ts);

    tokenizer->length = strlen(ts);
    
    tokenizer->ascii_hash = (bool *) calloc(128, sizeof(bool));
    if (tokenizer->ascii_hash == NULL) {
	return NULL;
    }
    else {
	for (i=0; i<128; i++) {
	    printf("%d",tokenizer->ascii_hash[i]);
	}
	printf("\n----\n");
    }
   

    /* if fail, return 
    return NULL;*/
    tokenizer->pos = 0;
    return tokenizer;
}

/*
 * TKDestroy destroys a TokenizerT object.  It should free all dynamically
 * allocated memory that is part of the object being destroyed.
 *
 * You need to fill in this function as part of your implementation.
 */

void TKDestroy(TokenizerT *tk) {
    free(tk->sep);
    tk->sep = NULL;

    free(tk->tokens_string);
    tk->tokens_string= NULL;

    free(tk);
    tk = NULL;

    return;
}

/*
char* ranged_substring( char *source, int start, int end) {
    char * outstring = NULL;
    printf("match @ %d!\n", tk->tokens_string[i]-0);	
    free(outstring);
    outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
    memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
    outstring[i] = '\0';
    i++;
    tk->pos = i;
    printf("i value = %d\t", i);
    printf("tk->pos value = %d\n", tk->pos);
    return outstring;
}

*/

void print_with_hex(char * token) {
    int i, loc;
    char escapes[9] = "ntvbrf\\a\"";
    int core[9] = {10,9,11,8,13,12,92,7,34};
    for (i=0; i<strlen(token)-1; i++) {
	for (loc=0; loc<10; loc++) {
	    if (token[i] == '\\' && (token[i+1] == escapes[loc])) {
		printf("\n");	
		printf("\n");	
		printf("\n");	
	    }
	}

    }
}

/*
 * TKGetNextToken returns the next token from the token stream as a
 * character string.  Space for the returned token should be dynamically
 * allocated.  The caller is responsible for freeing the space once it is
 * no longer needed.
 *
 * If the function succeeds, it returns a C string (delimited by '\0')
 * containing the token.  Else it returns 0.
 *
 * You need to fill in this function as part of your implementation.
 */

char *TKGetNextToken(TokenizerT *tk) {
    printf("split by token\n");
    int i=tk->pos;
    char * outstring = 0;
    if (tk->tokens_string[i] == '\0' || i >= tk->length) {
	return 0;
    }
    while (tk->tokens_string[i] != '\0' || i < tk->length) {
	printf("%c\n", tk->tokens_string[i]); 

	/* this is if there's a slash that isn't the last one  */
	if (tk->tokens_string[i] == '\\' && tk->tokens_string[i+1] != '\0') {
	    if (tk->tokens_string[i+1] == 'b') {
		free(outstring);
		outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
		memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
		outstring[i] = '\0';

		/* this is if the escape seq is in the delims  */
		if (tk->ascii_hash[8] == true) {
		    i++;
		    i++;
		}

		/* if it isn't, just split on the slash  */
		else { 
		    i++;
		}
		tk->pos = i;
		printf("i value = %d\t", i);
		printf("tk->pos value = %d\n", tk->pos);
		return outstring;
	    }

	    else if (tk->tokens_string[i+1] == 'n') {
		free(outstring);
		outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
		memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
		outstring[i] = '\0';
		if (tk->ascii_hash[10] == true) {
		    i++;
		    i++;
		}
		else { 
		    i++;
		}
		tk->pos = i;
		printf("i value = %d\t", i);
		printf("tk->pos value = %d\n", tk->pos);
		return outstring;
	    }

	    else if (tk->tokens_string[i+1] == 't') {
		free(outstring);
		outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
		memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
		outstring[i] = '\0';
		if (tk->ascii_hash[9] == true) {
		    i++;
		    i++;
		}
		else {
		    i++;
		}
		tk->pos = i;
		printf("i value = %d\t", i);
		printf("tk->pos value = %d\n", tk->pos);
		return outstring;
	    }

	    else if (tk->tokens_string[i+1] == 'v') {
		free(outstring);
		outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
		memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
		outstring[i] = '\0';
		if (tk->ascii_hash[11] == true) {
		    i++;
		    i++;
		}
		else {
		    i++;
		}
		tk->pos = i;
		printf("i value = %d\t", i);
		printf("tk->pos value = %d\n", tk->pos);
		return outstring;
	    }
	    else if (tk->tokens_string[i+1] == 'r') {
		free(outstring);
		outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
		memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
		outstring[i] = '\0';
		if (tk->ascii_hash[13] == true) {
		    i++;
		    i++;
		}
		else {
		    i++;
		}
		tk->pos = i;
		printf("i value = %d\t", i);
		printf("tk->pos value = %d\n", tk->pos);
		return outstring;
	    }
	    else if (tk->tokens_string[i+1] == 'f') {
		free(outstring);
		outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
		memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
		outstring[i] = '\0';
		if (tk->ascii_hash[12] == true) {
		    i++;
		    i++;
		}
		else {
		    i++;
		}
		tk->pos = i;
		printf("i value = %d\t", i);
		printf("tk->pos value = %d\n", tk->pos);
		return outstring;
	    }

	    else if (tk->tokens_string[i+1] == '\\') {
		free(outstring);
		outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
		memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
		outstring[i] = '\0';
		if (tk->ascii_hash[92] == true) {
		    i++;
		    i++;
		}
		else {
		    i++;
		}
		tk->pos = i;
		printf("i value = %d\t", i);
		printf("tk->pos value = %d\n", tk->pos);
		return outstring;
	    }
	    else if (tk->tokens_string[i+1] == 'a') {
		free(outstring);
		outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
		memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
		outstring[i] = '\0';

		if (tk->ascii_hash[7] == true) {
		    i++;
		    i++;
		}
		else {
		    i++;
		}
		tk->pos = i;
		printf("i value = %d\t", i);
		printf("tk->pos value = %d\n", tk->pos);
		return outstring;

	    }
	    else if (tk->tokens_string[i+1] == '\"') {
		free(outstring);
		outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
		memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
		outstring[i] = '\0';
		if (tk->ascii_hash[34] == true) {
		    i++;
		    i++;
		}
		else {
		    i++;
		}
		tk->pos = i;
		printf("i value = %d\t", i);
		printf("tk->pos value = %d\n", tk->pos);
		return outstring;
	    }
	    else {
		/*only worry about the slash*/
		if (tk->ascii_hash[tk->tokens_string[i]-0] == true) {
		    free(outstring);
		    outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
		    memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
		    outstring[i] = '\0';
		    i++;
		    tk->pos = i;
		    printf("i value = %d\t", i);
		    printf("tk->pos value = %d\n", tk->pos);
		    return outstring;
		}
		else {

		}
	    }
	}

	/* a non slash char */
	else {
	    /* found in the hash_t */
	    if (tk->ascii_hash[tk->tokens_string[i]-0] == true) {
		printf("match @ %d!\n", tk->tokens_string[i]-0);	
		free(outstring);
		outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
		memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
		outstring[i] = '\0';
		i++;
		tk->pos = i;
		printf("i value = %d\t", i);
		printf("tk->pos value = %d\n", tk->pos);
		return outstring;
	    }
	    /* not in the hash_t */
	    else {
		printf("no match\n");
	    }

	}
	i++;
    }
    free(outstring);
    outstring = (char *) malloc ((i-(tk->pos)+1)*sizeof(char));
    memcpy(outstring, &tk->tokens_string[tk->pos], i-(tk->pos));
    outstring[i] = '\0';
    i++;
    tk->pos = i;
    printf("i value = %d\t", i);
    printf("tk->pos value = %d\n", tk->pos);
    return outstring;
}



void generateSeparatorHash(char* word, TokenizerT* tok) {
    printf("whole sep string = %s\n", word);
    int i;

    for (i=0; i<strlen(word); i++) {
	/* this handles all the escape sequences */
	if (word[i] == '\\' && i != strlen(word)-1) {
	    if (word[i+1] == 'b') {
		tok->ascii_hash[8] = true;
	    }

	    else if (word[i+1] == 'n') {
		tok->ascii_hash[10] = true;
	    }

	    else if (word[i+1] == 't') {
		tok->ascii_hash[9] = true;
	    }

	    else if (word[i+1] == 'v') {
		tok->ascii_hash[11] = true;

	    }
	    else if (word[i+1] == 'r') {
		tok->ascii_hash[13] = true;

	    }
	    else if (word[i+1] == 'f') {
		tok->ascii_hash[12] = true;

	    }
	    else if (word[i+1] == '\\') {
		tok->ascii_hash[92] = true;
	    }
	    else if (word[i+1] == 'a') {
		tok->ascii_hash[7] = true;

	    }
	    else if (word[i+1] == '\"') {
		tok->ascii_hash[34] = true;
	    }
	    else {
		/* treat the slash and char separately */
		tok->ascii_hash[word[i]-0] = true; 
		tok->ascii_hash[word[i+1]-0] = true;
	    }
	}
	/* this handles everything else */
	else {
	    tok->ascii_hash[word[i]-0] = true;
	}

	/*
	if (escape == true) {
	    currChar[1] = word[i];
	    printf("the escape seq = %s, or %d\n",currChar, (*currChar-0));
	    escape = false;
	}
	else {
	    if (word[i] == '\\') {
		printf("HERE LIES THE BEGINNING OF An escape sequence\n"); 
		escape = true; 
		currChar[0] = word[i];
		printf("escapey slash => %c\n", currChar[0]);
	    }
	    else {
		printf("@%d => %c", i, word[i]);
		printf(" or ");
		printf("%d\n", word[i]-0);
		escape = false;
		tok->ascii_hash[word[i]-0] = true;
	    }
	}
	*/
    }
}

void print_ascii_hash(bool* ascii_hash){
    int i;
    for (i=0; i<128; i++) {
	if (ascii_hash[i] == true) {
	}
    }
}


/*
 * main will have two string arguments (in argv[1] and argv[2]).
 * The first string contains the separator characters.
 * The second string contains the tokens.
 * Print out the tokens in the second string in left-to-right order.
 * Each token should be printed on a separate line.
 */

int main(int argc, char **argv) {

    if (argc != 3) {
	fprintf(stderr, "tokenizer - error, incorrect # of arguments.\nUsage: tokenizer [separator characters] [tokens string]\n");
	return 1;
    }

    else {
	//create tokenizer here
	TokenizerT *tk = TKCreate(argv[1], argv[2]);
	generateSeparatorHash(argv[1], tk);
	print_ascii_hash(tk->ascii_hash);
	char * next_token = TKGetNextToken(tk);
	while (next_token != NULL) {
	    printf("\nNEXT TOKEN = %s\n", next_token);
	    free(next_token);
	    next_token = TKGetNextToken(tk);
	}
	free(next_token);
	TKDestroy(tk);
	return 0;
    }
    
} 
